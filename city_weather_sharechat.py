# -*- coding: utf-8 -*-
"""city_weather_sharechat.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1A3_uCqbhty0mIas0gRKr5FpdvS3j71aR
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd 
import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

city_weather = pd.read_csv("/content/drive/MyDrive/city_weather.csv")

city_weather.tail()

city_weather.info()

# As there is no null character in the data set provided to us. We do not have to put an effort in handling the missing values 
# If in case the missing value was there we would have handled it in the following ways:
# 1. Delete the missing values if there are missing values more than 70% for a particular feature 
# 2. Replace the missing values by median of the remaining values 
# 3. We can also find the real importance of the missing values by putting up some random values and checking the correlation matrix. 
# If the correlation increases then we need the values for the missing part. 

import missingno as msno
msno.matrix(city_weather)

# Let's handle the data types and features. Unnamed feature is the same as the index of the rows in the dataset, hence we can 
# get rid of this feature 
city_weather.drop("Unnamed: 0", inplace=True, axis = 1)

city_weather.head()

# Feature date_txt should be converted to the datetime format in order to make the analysis smooth. 
from datetime import datetime
city_weather['date_txt'] =  pd.to_datetime(city_weather['date_txt'], format='%Y-%m-%d %H:%M:%S')

city_weather.info()

# Rest all datatypes seem fare and hence we can go into visuatlisation of the data set for now. 
city_weather.groupby("name").describe()
# This provides us with the statistical figures of the following data grouped by the city. This helps us in having a overview
# of statsitical parameters for each city

# Lets have a visual idea of the cities we are analysing 
!pip install git+git://github.com/geopandas/geopandas.git
import descartes 
import geopandas as gpd

gdf = gpd.GeoDataFrame(
    city_weather, geometry=gpd.points_from_xy(city_weather.lon, city_weather.lat))

# Note the geometry column in the data frame 
gdf.head()

# Merge the data 
city_weather['geometry'] = gdf.geometry

city_weather.head()

fig,ax = plt.subplots(figsize = (15,15))
street_map =gpd.read_file("/content/drive/MyDrive/states_india.geojson")

street_map.plot(ax=ax, alpha=0.4,color ='red')
gdf.plot(ax=ax, color='yellow', marker ='s')

gdf.plot(ax=ax, color='yellow', marker ='s')

# Let's analyse the various features 
# We will strat with Temperature analysis 
import seaborn as sns
fig, ax =plt.subplots(3,1)
plt.figure(figsize=(10,10))
sns.boxplot(city_weather['temp_min'],orient='v',color='g',ax=ax[0])
sns.boxplot(city_weather['temp_max'],orient='v',color='b',ax=ax[1])
sns.boxplot(city_weather['temp'],orient='v',color='c',ax=ax[2])

fig.tight_layout()

# From the analysis we can say that all the three temperature values min_temp, max_temp and mean temperature are 
# overlapping with each other and have many outlier values as well. But as we know that we need these outlier values
# because the temperature will vary across the cities and we need to ensure that the temperature ranges for every city is 
# recorded well. Hence we will take care of this while choosing algorithm which can tackle this like Random Forest Algorithm 
# or an XGBOOST regressor. Removing these outliers will make me loose an important piece of information. Same goes with 
# every feature in this analysis. 
# We can handle the outliers in the following manner : 
# 1. Calculating the Z Score and eliminating those who fall beyond the range of [-3,3].
# 2. Finding out the outliers using IQR. Anyone outside the range [Q1-1.5IQR, Q3+1.5IQR]
# 3. We can delete the outliers or can replace them by the median values of inliers.

# Minimum Temperature variation for all the cities 
plt.figure(figsize=(20,10))
ax = sns.swarmplot(x="name", y="temp_min", data=city_weather)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90, ha="right")

# Mean Temperature for all cities 
plt.figure(figsize=(20,10))
ax = sns.swarmplot(x="name", y="temp", data=city_weather)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90, ha="right")

# Maximum Temperature for all cities 
plt.figure(figsize=(20,10))
ax = sns.swarmplot(x="name", y="temp_max", data=city_weather)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90, ha="right")

# As min_temp, Max_temp and temp are very overlapping features and in this task we need to predict for minimum temprature
# Lets check the correlation matrix once to understand how strong a correlation is between these features
plt.figure(figsize=(15,15))
ax = sns.heatmap(city_weather.corr(), square=True, annot=True, fmt='.2f')
ax.set_xticklabels(ax.get_xticklabels(), rotation=90)          
plt.show()

# From the above correlation matrix it is clear that all the temperature features are highly correlative 
# So we need to get rid of two of them to ensure that our algorithm works finely 

city_weather.drop(["temp","temp_max"],inplace=True, axis =1 )

plt.figure(figsize=(15,15))
ax = sns.heatmap(city_weather.corr(), square=True, annot=True, fmt='.2f')
ax.set_xticklabels(ax.get_xticklabels(), rotation=90)          
plt.show()

# From the correlation matrix we also understand that our two features sea_level and pressure are highly correlated 
# Hence lets analyse these two features first with ground level 

plt.figure(figsize=(20,10))
ax = sns.pointplot(x="name", y="sea_level", data=city_weather,dodge=True)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90, ha="right")

# ground level 
plt.figure(figsize=(20,10))
ax = sns.pointplot(x="name", y="grnd_level", data=city_weather,dodge=True)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90, ha="right")

# Hence we can observe that ground level has quite an opposite profile to the sea level. Sea level-ground level will 
# provide us a better data of the above sea level. Rather than having both these features, we can simply reduce 
# to above sea level feature 

city_weather["above_sea_level"] = city_weather["sea_level"]-city_weather["grnd_level"]

city_weather.drop(["sea_level","grnd_level"],inplace=True, axis =1 )

# Above Sea level 
plt.figure(figsize=(20,10))
ax = sns.pointplot(x="name", y="above_sea_level", data=city_weather,dodge=True)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90, ha="right")

# lets have a look at pressure over various cities for a period of 5 days 
plt.figure(figsize=(20,10))
ax = sns.swarmplot(x="name", y="pressure", data=city_weather)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90, ha="right")

# lets have a look at mean pressure over various cities for a period of 5 days 
plt.figure(figsize=(20,10))
ax = sns.pointplot(x="name", y="pressure", data=city_weather,dodge=True)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90, ha="right")

# Lets look at the correlation diagram to understand the correlation between various features 
# We have got rid of any strong correlation between the features 
plt.figure(figsize=(15,15))
ax = sns.heatmap(city_weather.corr(), square=True, annot=True, fmt='.2f')
ax.set_xticklabels(ax.get_xticklabels(), rotation=90)          
plt.show()

# Lets have a look at the situation of wind direction and wind speed 
plt.figure(figsize=(20,10))
ax = sns.swarmplot(x="name", y="wind_speed", data=city_weather)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90, ha="right")

plt.figure(figsize=(20,10))
ax = sns.pointplot(x="name", y="wind_speed", data=city_weather,dodge=True)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90, ha="right")

# Lets have a look at wind direction over a period of 5 days 
plt.figure(figsize=(20,10))
ax = sns.pointplot(x="name", y="wind_direction_deg", data=city_weather,dodge=True)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90, ha="right")

plt.figure(figsize=(20,10))
ax = sns.swarmplot(x="name", y="wind_direction_deg", data=city_weather)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90, ha="right")

# Humidity 
plt.figure(figsize=(20,10))
ax = sns.swarmplot(x="name", y="humidity", data=city_weather)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90, ha="right")

#Clouds: This data is shown to be equally distributed on both ends and it will show a specific meaning when analysed city wise 
# bsed upon time and date 
plt.figure(figsize=(20,10))
ax = sns.swarmplot(x="name", y="clouds", data=city_weather)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90, ha="right")

# Rain 
plt.figure(figsize=(20,10))
ax = sns.swarmplot(x="name", y="rain", data=city_weather)
ax.set_xticklabels(ax.get_xticklabels(), rotation=90, ha="right")

def city_specific_visualisation(x):
    df = city_weather[city_weather.name == x]
    fig, ax =plt.subplots(6,1,figsize=(20,20))
    df.groupby(pd.Grouper(key='date_txt',freq='D')).humidity.mean().plot(ax = ax[0])
    ax[0].set_ylabel('humidity %')
    df.groupby(pd.Grouper(key='date_txt',freq='D')).temp_min.mean().plot(ax = ax[1])
    ax[1].set_ylabel('Minimum Temperature')
    df.groupby(pd.Grouper(key='date_txt',freq='D')).clouds.mean().plot(ax = ax[2])
    ax[2].set_ylabel('clouds')
    df.groupby(pd.Grouper(key='date_txt',freq='D')).rain.mean().plot(ax = ax[3])
    ax[3].set_ylabel('Rain')
    df.groupby(pd.Grouper(key='date_txt',freq='D')).pressure.mean().plot(ax = ax[4])
    ax[4].set_ylabel('pressure')
    df.groupby(pd.Grouper(key='date_txt',freq='D')).wind_speed.mean().plot(ax = ax[5])
    ax[5].set_ylabel('Wind Speed')
    ax[5].set_xlabel("{} : date wise distribution of parameters".format(x))

city_names = city_weather.name.unique()

for x in city_names:
    city_specific_visualisation(x)

# Model Fitting 
city_weather.info()

# We do not need lat and lon features for our purpose currently 
city_weather.drop(["lat","lon"],inplace=True, axis=1)

city_weather.drop(["geometry"],inplace=True,axis=1)

# As country remains the same i.e India we do not need to include this column as well 
city_weather.drop(["country"],inplace=True,axis=1)

city_weather.info()

city_weather.describe()

import pickle as pkl
import os

CITY_WEATHER = os.path.join("..", "content", 'drive','MyDrive',"city_weather.pkl") 
pd.to_pickle(city_weather, CITY_WEATHER)

